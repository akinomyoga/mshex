#!/bin/bash

function mshex.yn {
  local prompt_yn='yes/no'
  local ret_default=
  case "$1" in
  -y)
    ret_default=0
    prompt_yn='Yes/no'
    shift ;;
  -n)
    ret_default=1
    prompt_yn='yes/No'
    shift ;;
  esac

  while read -ep "$* ($prompt_yn): " line; do
    case "x${line,,}" in
    (xyes)
      return 0 ;;
    (xno)
      return 1 ;;
    (x)
      if test -n "$ret_default"; then
        if test "$ret_default" -eq 0; then
          echo "$* ($prompt_yn): yes"
        else
          echo "$* ($prompt_yn): no"
        fi
        return "$ret_default"
      fi ;;
    esac
  done
}

#------------------------------------------------------------------------------
# read arguments

function usage_exit {
  echo "usage: refact [options...] beforeExtendedRegex afterText [files...]" >&2
  exit 1
}
function print_help {
  ifold <<EOF
usage: refact [options...] extended_regex after

OPTIONS

  --help        show this help

  -b, --word-boundary
  -B, --no-word-boundary
        set or reset the word-boundary condition.
        boundary is not set by default.

  -F, --fixed-strings

  -Wg,GRCOPTIONS
        set options for grc
        GRCOPTIONS is the options for grc separated with comma.

EOF
}

grc_options=(--color)
inputfiles=()

regex_type=E

fB=

flagDone=
flagError=
before= flagBeforeSpecified=
after=  flagAfterSpecified=
while (($#)); do
  declare arg="$1"; shift
  case "$arg" in
  (-b|--word-boundary)      fB=1 ;;
  (-B|--no-word-boundary)   fB= ;;
  (-F|--fixed-strings) regex_type=F ;;
  (-Wg,?*)
    IFS=, eval 'grc_options+=(${1:4})' ;;
  (--help)
    print_help; flagDone=1 ;;
  (-*)
    echo "refact: unknown option ($1)." >&2
    flagError=1 ;;
  (*)
    if [[ ! $flagBeforeSpecified ]]; then
      before=$arg
      flagBeforeSpecified=1
    elif [[ ! $flagAfterSpecified ]]; then
      after=$arg
      flagAfterSpecified=1
    else
      if [[ ! -f $arg ]]; then
        if [[ -e $arg ]]; then
          echo "refact: the specified path \`$arg' is not a regular file." >&2
        else
          echo "refact: the specified file \`$arg' does not exist." >&2
        fi
        flagError=1
      fi
      inputfiles[${#inputfiles[@]}]=$arg
    fi
    ;;
  esac
done

[[ $flagDone ]] && exit 0

[[ $flagBeforeSpecified && $flagAfterSpecified ]] || flagError=1

if [[ $flagError ]]; then
  usage_exit
  exit "$flagError"
fi

# for debug
# fB=
# before=Check
# after=_check

#------------------------------------------------------------------------------
# construct pattern

# æ‹¡å¼µæ­£è¦è¡¨ç¾æ–‡å­—ã‚¯ãƒ©ã‚¹ã®æ–‡å­—é †åº
export LC_COLLATE=C

bpat="$before"
apat="$after"

# escape characters having special meanings in ERE.
function escape_regexchars {
  ret="$1"
  if [[ $ret == *['][\/^$.*+?{}()|']* ]]; then
    b=\] a='\]'; ret=${ret//"$b"/"$a"}
    b=\[ a='\['; ret=${ret//"$b"/"$a"}
    b=\\ a='\\'; ret=${ret//"$b"/"$a"}
    # b=\/ a='\/'; ret=${ret//"$b"/"$a"} # å¾Œã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã‚‹
    b=\^ a='\^'; ret=${ret//"$b"/"$a"}
    b=\$ a='\$'; ret=${ret//"$b"/"$a"}
    b=\. a='\.'; ret=${ret//"$b"/"$a"}
    b=\* a='\*'; ret=${ret//"$b"/"$a"}
    b=\+ a='\+'; ret=${ret//"$b"/"$a"}
    b=\? a='\?'; ret=${ret//"$b"/"$a"}
    b=\{ a='\{'; ret=${ret//"$b"/"$a"}
    b=\} a='\}'; ret=${ret//"$b"/"$a"}
    b=\( a='\('; ret=${ret//"$b"/"$a"}
    b=\) a='\)'; ret=${ret//"$b"/"$a"}
    b=\| a='\|'; ret=${ret//"$b"/"$a"}
  fi
}

function escape_regexchars_in_replacement {
  # ç½®æ›éƒ¨åˆ†ã«å«ã¾ã‚Œã†ã‚‹ç‰¹åˆ¥ãªæ–‡å­—: \1..\2\r\n\f\t\v\b\a &
  ret="$1"
  if [[ $ret == *['][\/^$.*+?{}()|']* ]]; then
    b=\] a='\]'; ret=${ret//"$b"/"$a"}
    b=\[ a='\['; ret=${ret//"$b"/"$a"}
    # b=\\ a='\\'; ret=${ret//"$b"/"$a"}
    # b=\/ a='\/'; ret=${ret//"$b"/"$a"} # å¾Œã§ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã‚‹
    b=\^ a='\^'; ret=${ret//"$b"/"$a"}
    b=\$ a='\$'; ret=${ret//"$b"/"$a"}
    b=\. a='\.'; ret=${ret//"$b"/"$a"}
    b=\* a='\*'; ret=${ret//"$b"/"$a"}
    b=\+ a='\+'; ret=${ret//"$b"/"$a"}
    b=\? a='\?'; ret=${ret//"$b"/"$a"}
    b=\{ a='\{'; ret=${ret//"$b"/"$a"}
    b=\} a='\}'; ret=${ret//"$b"/"$a"}
    b=\( a='\('; ret=${ret//"$b"/"$a"}
    b=\) a='\)'; ret=${ret//"$b"/"$a"}
    b=\| a='\|'; ret=${ret//"$b"/"$a"}
  fi
}

if [[ $regex_type == F ]]; then
  declare ret
  escape_regexchars "$bpat"
  bpat="$ret"
fi

if [[ $fB ]]; then
  [[ $bpat =~ ^[_[:alnum:]] ]] && bpat='\b'"$bpat"
  [[ $bpat =~ [_[:alnum:]]$ ]] && bpat="$bpat"'\b'

  [[ $apat =~ ^[_[:alnum:]] ]] && apat='\b'"$apat"
  [[ $apat =~ [_[:alnum:]]$ ]] && apat="$apat"'\b'
fi

sl=/
esl='\/'
bpat_escaped="${bpat//$sl/$esl}"
after_escaped="${after//$sl/$esl}"

#echo "dbg: bpat=($bpat) apat=($apat)"

#------------------------------------------------------------------------------
# search pattern

target_files=()
declare -A target_files_dict

echo --------- replace ---------

# time 0.672s
function enumerate_matches.i2 {
  exec 5>&1

  function search_target_files {
    # fd1 ã«ä¸€è‡´ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å‡ºåŠ›
    # fd5 ã«ä¸€è‡´ç®‡æ‰€ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’å‡ºåŠ›

    exec 6>&1
    grc --color "${grc_options[@]}" "$bpat" "${inputfiles[@]}" | gawk '
      {
        line=$0;
        gsub(/\x1b\[[ -?]*[@-~]/,"",line); # remove csi
        if(match(line,/^(([^:]|:[^0-9]|:[0-9]+[^:0-9])*):[0-9]+:/,m)>0){
          file=m[1];
          if(!target_files_dict[file]){
            target_files_dict[file]=1;
            print file > "/dev/fd/6";
            print ">>> " file;
          }
        }
        print $0;
      }
    ' | sed -r "
       /^>>> /!{
         h
         s/^/-/
         p
         g
         s/\[[ -?]*[@-~]//g
         s/${bpat_escaped}/${after_escaped}/g
         s/^/+/
       }
    " 1>&5
  }

  IFS=$'\n' eval 'result=($(search_target_files))'

  local file
  for file in "${result[@]}"; do
    test -f "$file" && target_files+=("$file")
  done
}

enumerate_matches.i2

if test "${#target_files[@]}" -le 0; then
  echo ---------------------------
  echo "refact: pattern ($bpat) not found!" >&2
  exit 2
fi
echo ------- collision? --------
declare ret
escape_regexchars_in_replacement "$after"
apat_coll="$ret"
grc "${grc_options[@]}" "$apat_coll" "${inputfiles[@]}"
echo ---------------------------

#------------------------------------------------------------------------------
# execute replace

mshex.yn -n "execute replace? " || exit 0

sedx="s/${bpat_escaped}/${after_escaped}/g"
sed -r -i "$sedx" "${target_files[@]}"

#------------------------------------------------------------------------------
