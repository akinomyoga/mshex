#!/bin/bash

function show_help {
  local bold=$'\e[1m'
  local ul=$'\e[4m'
  local cyan=$'\e[36m'
  local sgr0=$'\e[m'
  ifold -i -s <<EOF
usage: ren [${cyan}OPTIONS${sgr0}...] ${cyan}BEFORE${sgr0} ${cyan}AFTER${sgr0} [${cyan}FILES${sgr0}...]

${bold}${cyan}BEFORE${sgr0}

  Specify replacement target with the extended regex (POSIX ERE).

${bold}${cyan}AFTER${sgr0}

  Specify replacement result. \
The specifier ${ul}\$${cyan}N${sgr0} in the ${cyan}AFTER${sgr0} will be replaced by the captured text corresponding to ${cyan}N${sgr0}'th \`${ul}()${sgr0}' in ${cyan}BEFORE${sgr0}. \
If the option \`${ul}-x${sgr0}' or \`${ul}--shell-expand${sgr0}' is specified, \
shell expansion is applied to the ${cyan}AFTER${sgr0} after finishing the replacement of ${ul}\$${cyan}N${sgr0}.

${bold}OPTIONS${sgr0}

  ${bold}-x, --shell-expand${sgr0}
    apply shell expansion to ${cyan}AFTER${sgr0}.

  ${bold}--help${sgr0}
    show this help.

  ${bold}-b, --backup${sgr0}
  ${bold}-f, --force${sgr0}
  ${bold}-i, --interactive${sgr0}
  ${bold}-n, --no-clobber${sgr0}
    These options control the treatment of existing files. \
If multiple options of ${ul}-b${sgr0}, ${ul}-f${sgr0}, ${ul}-i${sgr0}, and ${ul}-n${sgr0} are specified, the one specified last is used. \
The option \`${ul}-b${sgr0}' specifies that the existing option will be renamed by adding suffix. \
The suffix is specified by \`${ul}--suffix=SUFFIX${sgr0}' option. \
The default suffix is \`${ul}~${sgr0}'. \
The option \`${ul}-f${sgr0}' specifies that the existing files will be overwritten. \
The option \`${ul}-i${sgr0}' specifies that it is asked for each existing file whether the file is to be overwritten. \
The option \`${ul}-n${sgr0}' specifies that the rename is skipped if there already an existing file.

  ${bold}-S, --suffix=${cyan}SUFFIX${sgr0} [default ${ul}~${sgr0}]

  ${bold}--${sgr0}
    Specify that the later arguments are treated as file names.
EOF

}

declare fEval= fError=
declare fOverwriteMode= fBackupSuffix=\~
declare ren_before ren_after files
files=()
while (($#)); do
  declare arg="$1"
  shift
  case "$arg" in
  (-x|--shell-expand) fEval=1 ;;
  (-b|--backup)      fOverwriteMode=b ;;
  (-f|--force)       fOverwriteMode=f ;;
  (-i|--interactive) fOverwriteMode=i ;;
  (-n|--no-clobber)  fOverwriteMode=n ;;
  (--suffix=?*)      fBackupSuffix=${arg#--suffix=} ;;
  (-S)
    if (($#)); then
      fBackupSuffix="$1"
      shift
    else
      echo '[1;31mren[m: no argument of the option -S' >&2
      fError=1
    fi ;;
  (--)
    files=("${files[@]}" "$@")
    break ;;
  (--help)
    show_help
    exit ;;
  (*)
    if [[ ! ${ren_before+x} ]]; then
      ren_before="$arg"
    elif [[ ! ${ren_after+x} ]]; then
      ren_after="$arg"
    else
      files[${#files[@]}]="$arg"
    fi
  esac
done
export ren_before ren_after

if [[ ! ${ren_after+x} ]]; then
  echo '[1;31musage[m: ren before:rex after:txt [files...]' >&2
  exit 1
fi

if ((${#files[@]}==0)); then
  files=(*)
fi

function mshex.yn {
  local prompt_yn='yes/no'
  local ret_default=
  case "$1" in
  -y)
    ret_default=0
    prompt_yn='Yes/no'
    shift ;;
  -n)
    ret_default=1
    prompt_yn='yes/No'
    shift ;;
  esac

  while read -ep "$* ($prompt_yn): " line; do
    case "x${line,,}" in
    (xyes)
      return 0 ;;
    (xno)
      return 1 ;;
    (x)
      if test -n "$ret_default"; then
        if test "$ret_default" -eq 0; then
          echo "$* ($prompt_yn): yes"
        else
          echo "$* ($prompt_yn): no"
        fi
        return "$ret_default"
      fi ;;
    esac
  done
}

mv_option=-n

srclist=()
dstlist=()
quote="'\"'\"'"
while read -r src && read -r dst; do
  test ! -e "$src" && continue

  [[ $fEval ]] && IFS= GLOBIGNORE=\* eval "dst=($dst)"

  if
    for((j=0;j<${#dstlist[*]};j++)); do
      [[ "$dst" = "${dstlist[j]}" ]] && break
    done
    ((j<${#dstlist[*]}))
  then
    echo "[1;31mren[m: collision of the resulting filename '$dst'!" >&2
    continue
  fi

  if [[ -e $dst ]]; then
    case "$fOverwriteMode" in
    (b)
      echo "[34mren[m: the existing file %q will be backupped to %q.\n" "$dst" "$dst$fBackupSuffix"
      srclist+=("$dst")
      dstlist+=("$dst$fBackupSuffix") ;;
    (f)
      mv_option=-f
      printf "[34mwarning[m: The existing file %q will be overwritten.\n" "$dst" ;;
    (i)
      if mshex.yn -n "overwrite the existing file '$dst'? "; then
        mv_option=-f
        printf "[34mren[m: The existing file %q will be overwritten.\n" "$dst"
      else
        printf "[34mren[m: The rename, %q -> %q, will be skipped.\n" "$src" "$dst"
        continue
      fi ;;
    (n|*)
      printf "[34mren[m: The file already exists. The rename, %q -> %q, will be skipped.\n" "$src" "$dst"
      continue ;;
    esac
  fi

  srclist+=("$src")
  dstlist+=("$dst")
  printf "mv %q %q\n" "$src" "$dst"
done < <(
  # ※ファイル名に改行が含まれていると駄目
  declare f
  for f in "${files[@]}"; do echo "$f"; done | awk '
    #-------------------------------------------------------------------------------
    # replace
    function replace(text,before,after, _is_tmpl,_is_head,_captures,_rep,_ltext,_rtext){
      _is_tmpl=(match(after,/\$[0-9]+/)>0);
      _is_head=(substr(before,1,1)=="^");

      _ret="";
      while(match(text,before,_captures)>0){
        _ltext=substr(text,1,RSTART-1);
        _rtext=substr(text,RSTART+RLENGTH);
    
        _rep=_is_tmpl?rep_instantiate_tmpl(after,_captures):after;
    
        _ret=_ret _ltext _rep;
        text=_rtext;

        if(_is_head)break;
        if(RLENGTH==0){
          _ret=_ret substr(text,1,1);
          text=substr(text,2);
          if(length(text)==0)break;
        }
      }
      return _ret text;
    }
    function rep_instantiate_tmpl(text,captures,  _ret,_num){
      _ret="";
      while(match(text,/\$([0-9]+)/,_num)){
        #print "dbg: $ captured: RSTART=" RSTART "; num=" _num[1] "; captures[num]=" captures[_num[1]] > "/dev/stderr"
        _ret=_ret substr(text,1,RSTART-1) captures[_num[1]];
        text=substr(text,RSTART+RLENGTH);
      }
      return _ret text;
    }

    BEGIN{
      g_before=ENVIRON["ren_before"];
      g_after =ENVIRON["ren_after"];
    }
    {
      q=0x27;
      src=$0;
      dst=replace($0,g_before,g_after);

      if(src!=dst){
        # printf("mv -n %c%s%c %c%s%c\n",q,src,q,q,dst,q);

        # gsub("[\"\\\\$]","\\\\&",src);
        # gsub("[\"\\\\$]","\\\\&",dst);
        # printf("mv -n \"%s\" \"%s\"\n",src,dst);

        print src;
        print dst;
      }
    }
  '
)

if test ${#srclist[@]} -eq 0; then
  echo "ren: files to change do not exist."
  exit
fi

mshex.yn -n "execute rename? " || exit 0

for((i=0,iN=${#srclist[@]};i<iN;i++)); do
  mv $mv_option -v "${srclist[i]}" "${dstlist[i]}"
done
