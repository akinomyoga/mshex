#!/bin/bash

# settings

dir="$HOME/.recycle"

#------------------------------------------------------------------------------
# utils

shopt -s nullglob

# >>>>> yn.sh
#%include "../functions/yn.sh"
# <<<<< yn.sh

function upvar { unset "$1" && eval "$1=\"\$2\""; }

path_separator_pattern='[/\\]'
function escape_filename {
  local var=
  if [[ $1 == -v ]]; then
    var="$2"
    shift 2
  fi

  local value="$1"
  value="${value//%/%25}"
  value="${value//$path_separator_pattern/%2F}"

  if [[ $var ]]; then
    local "$var" && upvar "$var" "$value"
  else
    echo "$value"
  fi
}

function unescape_filename {
  local var=
  if [[ $1 == -v ]]; then
    var="$2"
    shift 2
  fi

  local value="$1"
  value="${value//%2F/'/'}"
  value="${value//%25/%}"

  if [[ $var ]]; then
    local "$var" && upvar "$var" "$value"
  else
    echo "$value"
  fi
}

#------------------------------------------------------------------------------

function show-help {
  ifold <<EOF
usage: remove [options] file...

OPTIONS

  -?, --help
        show this help

  -r, --recursive

  -i, --interactive[=always]
        prompt before every removal
  -I, --interactive=once
        list removed files and prompt once.

  -f, --force
  -v, --verbose

  -s

EOF
}

a_dir=$'\e[94m'
a_link=$'\e[96m'
a_pipe=$'\e[40;94m'
a_sock=$'\e[40;96m'
a_char=$'\e[40;97m'
a_block=$'\e[40;93m'
a_exec=$'\e[92m'
a_stick=$'\e[32;41m'
a_file=$'\e[m'
E_miss=$'\e[91m'
E_ovwrt=$'\e[1;30m'
sgr0=$'\e[m'

function subcommand:list-garbages/color-filename {
  if [[ -t 1 ]]; then
    if [[ -d $gfile ]]; then
      _file="$a_dir$file$sgr0"
    elif [[ -h $gfile ]]; then
      _file="$a_link$file$sgr0"
    elif [[ -p $gfile ]]; then
      _file="$a_pipe$file$sgr0"
    elif [[ -S $gfile ]]; then
      _file="$a_sock$file$sgr0"
    elif [[ -b $gfile ]]; then
      _file="$a_block$file$sgr0"
    elif [[ -x $gfile ]]; then
      if [[ -k $gfile ]]; then
        _file="$a_stick$file$sgr0"
      else
        _file="$a_exec$file$sgr0"
      fi
    else
      _file="$a_file$file$sgr0"
    fi
  fi
}

function subcommand:list-garbages/color-directory {
  if [[ -t 1 ]]; then
    if [[ -d $wdir ]]; then
      _wdir="$a_dir$wdir$sgr0"
    else
      _wdir="$E_miss$wdir$sgr0"
    fi
  fi
}

function subcommand:list-garbages/check-newfile {
  if [[ -e $1 ]]; then
    if [[ -t 1 ]]; then
      _file="$_file $E_ovwrt*$sgr0"
    else
      _file="$_file *"
    fi
  fi
}

function subcommand:list-garbages {
  [[ -d $dir/wait ]] || return
  local entry
  local date time gfile wdir
  local rtime file opath
  local _wdir _file
  for entry in $dir/wait/*; do
    [[ -e $entry ]] || continue
    entry="${entry#"$dir/wait/"}"

    if [[ $entry == ????????-??????-* ]]; then
      date="${entry::8}"
      time="${entry:9:6}"
      gfile="$dir/wait/$entry"
      file="${entry:16}"
      unescape_filename -v file "$file"

      rtime="${date::4}-${date:4:2}-${date:6} ${time::2}:${time:2:2}:${time:4}"
      subcommand:list-garbages/color-filename
      subcommand:list-garbages/check-newfile "$file"
      echo "$rtime $_file"
    elif [[ $entry == ????????-??????@* ]]; then
      date="${entry::8}"
      time="${entry:9:6}"
      wdir="${entry:16}"
      unescape_filename -v wdir "$wdir"

      rtime="${date::4}-${date:4:2}-${date:6} ${time::2}:${time:2:2}:${time:4}"
      subcommand:list-garbages/color-directory
      echo "$rtime $_wdir"

      for gfile in "$dir/wait/$entry"/{*,.*}; do
        file="${gfile#"$dir/wait/$entry"/}"
        [[ $file == . || $file == .. ]] && continue
        unescape_filename -v file "$file"

        subcommand:list-garbages/color-filename
        subcommand:list-garbages/check-newfile "$wdir/$file"
        echo "${rtime//?/ }  \__ $_file"
      done
    else
      echo unknown entry
    fi
  done
}

#------------------------------------------------------------------------------
# read options
fR=
fI=
fF=
fV=
fS=

fDone=
fHelp=
fError=
files=()

while (($#)); do
  declare arg="$1" i
  shift
  case "$arg" in
  (--help)          fHelp=1 ;;
  (--recursive)     fR=1 ;;
  (--force)         fF=1 ;;
  (--verbose)       fV=1 ;;
  (--interactive)   fI=always ;;
  (--interactive=*) fI=${arg#--interactive=}
                    : ${fI:=always}
                    [[ $fI == none ]] && fI=
                    ;;
  (--*)
    fError=1
    echo "mshex/remove: unrecognized option \`$arg'." >&2 ;;
  (-?*)
    for ((i=1;i<${#arg};i++)); do
      case "${arg:i:1}" in
      (i) fI=always ;;
      (I) fI=once   ;;
      (r) fR=1  ;;
      (f) fF=1  ;;
      (v) fV=-v ;;
      (s) fS=1  ;;
      (l) subcommand:list-garbages
          fDone="$?" ;;
      (*)
        fError=1
        echo "mshex/remove: unrecognized option \`-${arg:i:1}'" >&2 ;;
      esac
    done ;;
  (*)
    files[${#files[@]}]="$arg" ;;
  esac
done

if [[ $fHelp ]]; then
  show-help
  [[ ! $fError ]]
  exit
fi

[[ $fDone ]] && exit "$fDone"

if ((${#files[@]}==0)); then
  echo "mshex/remove: no files to remove are specified" >&2
  exit 1
fi

# checking files
if [[ ! $fR || ! $fF ]]; then
  declare file
  for file in "${files[@]}"; do
    if [[ ! $fF && ! ( -e $file || -h $file ) ]]; then
      echo "mshex/remove: '$file' does not exist!" >&2
      exit 1
    elif [[ ! $fR && -d $file && ! -h $file ]]; then
      echo "mshex/remove: '$file' is directory! (use -r option to remove directory)" >&2
      exit 1
    fi
  done
fi

[[ $fError ]] && exit 1

#------------------------------------------------------------------------------
# create backup directory
mkd () { test -d "$1" || mkdir -p "$1"; }
now="$(date +%Y%m%d-%H%M%S)"

delete_waiting_files () {
  [[ -d $dir/wait ]] || return

  local -a gomigomi=()
  for file in "$dir"/wait/[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9]*; do
    local date="${file#$dir/wait/}"
    date="${date:0:8}"
    if ((date+100<${now::8})); then
      gomigomi[${#gomigomi[@]}]="$file"
    fi
  done

  if ((${#gomigomi[@]}>0)); then
    mkd "$dir/gomi"
    mv $fV "${gomigomi[@]}" "$dir/gomi/"
  fi
}

delete_waiting_files

destination="$dir/wait"
[[ $fS ]] && destination="$dir"
mkd "$destination"

if [[ $fI == once ]]; then
  {
    echo '-- filelist --'
    find -- "${files[@]%/}"
  } | less -XSF

  mshex.yn -n "mshex/remove: remove the above files?" || exit 2
  fI=
fi

function interactive_confirm_file {
  local file="$1"
  [[ ! $fI ]] && return 0

  local ft='an unknown-type file'
  if [[ -d $file ]]; then
    ft='a directory'
  elif [[ -p $file ]]; then
    ft='a named pipe'
  elif [[ -b $file ]]; then
    ft='a block device'
  elif [[ -s $file ]]; then
    ft='a socket'
  elif [[ -h $file ]]; then
    ft='a symbolic link'
  elif [[ -f $file ]]; then
    if [[ ! -s $file ]]; then
      ft='an empty file'
    elif [[ -x $file ]]; then
      ft='an executable file'
    else
      ft='a regular file'
    fi
  fi

  mshex.yn "mshex/remove: $ft '$file'?"
}

## @var[in] destination
## @var[in] now
## @var[in] files[]
function remove_impl {
  if ((${#files[@]}==1)); then
    local src="${files[0]%/}" dst esc
    interactive_confirm_file "$src" || return
    escape_filename -v esc "$PWD/$src"
    dst="$destination/$now-$esc"
    while [[ -e $dst ]]; do dst="$dst+"; done
    mv $fV -- "$src" "$dst"
  elif ((${#files[@]}>=2)); then
    local dst esc

    # prepare dst directory
    escape_filename -v esc "$PWD"
    dst="$destination/$now@$esc"
    while [[ -e $dst ]]; do dst="$dst+"; done
    mkdir "$dst"

    local file
    local -a raws=()
    for file in "${files[@]}"; do
      interactive_confirm_file "$file" || continue
      escape_filename -v esc "$file"
      if [[ $esc != "$file" ]]; then
        mv $fV -- "$file" "$dst/$esc"
      else
        raws[${#raws[@]}]="$file"
      fi
    done
    ((${#raws[@]})) && mv $fV -- "${raws[@]}" "$dst"/
  fi
}

remove_impl
