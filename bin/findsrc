#!/bin/bash

fNoExtension=
extensions=()
excludesDotFiles=1
excludesBackup=1
excludedPatterns=()

typeSpecified=
typeC=
typeJs=
typeF=
typeEl=
typeSh=
typeAll=

function add_extensions {
  [[ "$1" =~ ^:|::|:$ ]] && fNoExtension=1

  IFS=: eval 'local arr=($1) ext'
  for ext in "${arr[@]}"; do
    test -n "$ext" && extensions+=("${ext#.}")
  done
}

function read_arguments {
  while (($#)); do
    local arg="$1"
    shift
    case "$arg" in
    (-x)  add_extensions "$1"; shift 1 ;;
    (-x*) add_extensions "${arg:2}" ;;
    (-a) # do not exclude dotfiles
      excludesDotFiles= ;;
    (-b) # do not exclude backups
      excludesBackup=   ;;
    (--exclude=*)
      excludedPatterns+=("${arg#--exclude=}") ;;
    (-*)
      echo "${title:-findsrc}: uknown option ($1)" >&2
      exit 2 ;;
    (c|'c++') typeSpecified=1 typeC=1 ;;
    (js)      typeSpecified=1 typeJs=1 ;;
    (f)       typeSpecified=1 typeF=1 ;;
    (el)      typeSpecified=1 typeEl=1 ;;
    (sh)      typeSpecified=1 typeSh=1 ;;
    (all)     typeSpecified=1 typeAll=1 ;;
    (*)
      echo "${title:-findsrc}: unrecognized type '$1'" >&2
      exit 1 ;;
    esac
  done
}

function read_arguments_from_dotfile {
  local dir="$PWD"
  while
    local foption="$dir/.src"
    [[ ! -f "$foption" ]]
  do
    [[ ! $dir ]] && return
    dir="${dir%/*}"
  done

  local title line rex='(^|[ 	])#.+$' iline=0
  while IFS= read -r line || [[ $line ]]; do
    ((iline++))
    [[ $line =~ $rex ]] &&
      line=${line::${#line}-${#BASH_REMATCH}}
    title="$foption:$iline" read_arguments $line
  done < "$foption"
}

read_arguments_from_dotfile
read_arguments "$@"

[[ $typeC   || -z $typeSpecified ]] && extensions+=(c h inl cpp cxx hpp hxx)
[[ $typeJs  || -z $typeSpecified ]] && extensions+=(js ctx css)
[[ $typeF   || -z $typeSpecified ]] && extensions+=(f inc)
[[ $typeEl  || -z $typeSpecified ]] && extensions+=(el)
[[ $typeSh  || -z $typeSpecified ]] && extensions+=(sh src)
[[ $typeAll ]] && fALL=1 extensions+=(all)


function pat2regex {
  # (|){}^$ 等は意味を保持する (ファイル名に用いられそうにないから)
  local pat="$1"
  pat="${pat//+/\\+}"
  pat="${pat//./\\.}"
  pat="${pat//'?'/[^/]}"
  pat="${pat//'**'/.*}"
  pat="${pat//'*'/[^/]*}"
  regex="(^|/)$pat(/|$)"
  # echo dbg: pat2regex $regex >&2
}

# egrep -v の引数を構築
function grepv_excludes.construct {
  grepv_excludes=('^$')

  if [[ $excludesBackup ]]; then
    grepv_excludes+=('/backup/|\.[[:digit:]]{8}($|\.\w+)')
    [[ $fALL ]] && grepv_excludes+=('~$')
  fi

  if [[ $excludesDotFiles ]]; then
    grepv_excludes+=('/\.[^/]')
  fi

  for ((i=0;i<${#excludedPatterns[*]};i++)); do
    local regex
    pat2regex "${excludedPatterns[i]}"
    grepv_excludes+=("$regex")
  done

  IFS='|' eval 'grepv_excludes="${grepv_excludes[*]}"'
}
grepv_excludes.construct

# 実行
if test -n "$fALL"; then
  find | \egrep -v "$grepv_excludes"
else
  declare rex
  IFS='|' eval 'rex=".+\.(${extensions[*]})"'
  if [[ $typeC || ! $typeSpecified ]]; then
    declare cxx_headers=(
      cassert cctype cerrno cfenv cfloat cinttypes ciso646 climits clocale
      cmath csetjmp csignal cstdarg cstdbool cstddef cstdint cstdio cstdlib
      cstring ctgmath ctime cuchar cwchar cwctype array bitset deque
      forward_list list map queue set stack unordered_map unordered_set
      vector atomic condition_variable future mutex thread algorithm chrono
      codecvt complex exception functional initializer_list iterator limits
      locale memory new numeric random ratio regex stdexcept string
      system_error tuple typeindex typeinfo type_traits utility valarray
    )
    IFS='|' eval 'rex+="|(.*/)?(${cxx_headers[*]})"'
  fi
  
  # 処理系によって正規表現が異なる (因みに -regex option は非 POSIX 標準の様だ)
  find -regextype posix-extended -type f -and -regex "$rex" | \egrep -v "$grepv_excludes"
  # find -regex '..*\.\('"${rex_extensions//|/\\|}"'\)'|egrep -v '/backup/|\.[[:digit:]]{8}\.\w+'
fi
